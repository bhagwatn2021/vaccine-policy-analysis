---
title: "Pilot Analysis"
subtitle: "Comparison of different policy options to increase COVID-19 vaccination rates."
author: Jenny Kim, Neel Bhagwat
date: October 27, 2021 
output: 
  html_document:
    toc: true 
    toc_float: true
    number_sections: false
---

```{r setup, echo=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE,
  comment = "#>",
  fig.path = "figs/", # Folder where rendered plots are saved
  fig.width = 7.252, # Default plot width
  fig.height = 4, # Default plot height
  fig.retina = 3 # For better plot resolution
)

# Load libraries here
library(tidyverse)
library(here)
```

Write your report content here.

Make sure you update the settings in the YAML for your report. 

Use [markdown](https://commonmark.org/help/) for formatting, e.g.: **Bold**, _Italic_, etc.

Here are some section headers to use: 

# Abstract

This study focuses on the various policies that the US Federal government can enact to increase COVID-19 vaccination rates and stabilize the spread of COVID-19 with herd immunity. It compares a vaccine mandate enforced with a fine, the policy in question, to various incentives such as tax rebates and sporting tickets. It also takes into account the accessibility of vaccination centers, measured by the proximity of vaccination centers from residencies, as well as combinations of these different policy attributes. The target population for this study are all Americans 18 years and older who have not received a dose of a COVID-19 vaccine. Below are lists of all possible values of each attribute included in the choice questions: 

```{r echo=FALSE}
incentive = c("Grocery Store Gift Card", "Internet Rebate", "Sporting Tickets", "Cash")
value = c(0, 50, 100, 200, 300, 500, 1000)
penalty = c(0, 50, 100, 200, 300, 500, 1000)
accessibility = c(0, 1, 3, 10) # Distance (miles) from a vaccination center

```
Accessibility (miles from residency): 
```{r echo=FALSE}
accessibility
```
Incentive (cateogrical): 
```{r echo=FALSE}
incentive
```
Mandate Fine (USD, no mandate for values of $0): 
```{r echo=FALSE}
penalty
```
Incentive Value (USD, no incentive for values of $0): 
```{r echo=FALSE}
value
```

# Introduction

Despite the rollout of COVID-19 vaccines, vaccine hesitancy prevented the United States from achieving herd immunity, the level of immunity that a population has to control the spread of a virus. Below is a chart depicting the number of daily vaccinations over time as a percentage of the population, followed by a chart depicting the percentage of the American population that is vaccinated: 

<center>
  <img src="images/daily-vaccinations.png" width=1500>
</center>

<center>
  <img src="images/total-vaccinations.png" width=1500>
</center>

In turn, the Delta variant, a highly-contagious strain of SARS-COV-2, the virus that causes COVID-19, ravaged through unvaccinated populations and caused a surge in cases. 


### Accessibility

Accessibility refers to the distance which a vaccination clinic would be placed from your home. It varies with 0 (door-door vaccinations) - 10 miles from your residence. 


### Incentives

Incentives refers to the type of commodity that would be given out at tax season for being fully vaccinated against COVID-19 by the tax return deadline. It varies by cash tax rebates and cash equivalents (gift cards) redeemable at:

- Grocery stores
- Internet providers
- Professional sporting events 

### Incentive Value 

Incentive value refers to the value of commodities that would be given out at tax season for  being fully vaccinated against COVID-19 by the tax return deadline. It varies by increasing increments from $0 to $1000. 

### Penalty

Incentive value refers to the penalty due at tax season for failing to get a  being fully vaccinated against COVID-19 by the tax return deadline under a vaccine mandate. It varies by increasing increments from $0 to $1000. 

# Survey Design


# Pilot Data Analysis

### Data Cleaning 

When we first opened the responses from the three separate components, we noticed a lot of null values to numerous attributes, including session ids that seemed to be from unsuccessful attempts to view our survey, or from bots on the internet. To remove these values gracefully, we had to join these three components together by the session id, a unique identifier for each participant associated with the survey. To do so, we took out duplicate columns and removed null values for session. We also computed the time took to complete each survey component in unique columns. Then, we filtered out respondents that did not answer the choice questions and did not meet eligibility criteria. There were about 20-30 total respondents, but the actual number is not known because some responses on each part were due to unsuccessful attempts to take the survey (i.e. partial responses, bots, poor network connection, etc.).

## Sample Description

The final pilot survey sample after cleaning consists of 7 respondents who answered all 10 choice questions and met the eligibility criteria. The choice data sheet contains of 20 rows per respondent, denoting 2 alternatives per question (will you take the vaccine under this condition or not?) and 10 questions each. 



```{r echo=FALSE}
data <- read_csv(here("data", "choiceData.csv"))
data
```
### Demographic Analysis

To analyze our sample by each demographic factor, we first filtered out any respondent who did not answer the particular demographic question. We then grouped respondents by demographic and divided the number of responses to each demographic by 20 (since each respondent appears 20 times on the survey) to get the number of respondents in each demographic attribute level. 

We were first interested in the politics of our respondents. We found that most of our sample was liberal, with a couple independents and leaning conservatives. This deviates from our ideal sample - we will need responses across a wide political spectrum and we will need more samples in each category - a liberal sample may skew responses towards agreeing to take the vaccine under smaller conditions. 
```{r echo=FALSE}
political_label <- c("Strongly conservative", "Conservative", "Leaning conservative",	"Moderate", "Leaning liberal",	"Liberal",	"Strongly liberal",	"Independent",	"Prefer not to say")
politics <- c(1:9)
politics_df <- data.frame(politics,political_label)
politics <- data %>% filter(!is.na(politics)) %>% select(politics) %>% group_by(politics) %>% summarise(num_respondents = n()/20) %>% inner_join(politics_df,by=c("politics"))

politics
```

We were also interested in the income brackets of our respondents. We found that most of our sample makes under $50,000 per year, which can give us insights about vaccine policies for poorer families, but we will need more responses from a higher income bracket to validate the effect of income on vaccine hesitancy. 
```{r echo=FALSE}

incomes <- data %>% select(income) %>% filter(!is.na(income)) %>%  group_by(income) %>% summarise(num_respondents = n()/20)
incomes
```

We then looked at the regions of residencies of our respondents. We found that our sample is overwhelmingly from the East Coast, with a few responses from the West Coast and the Rocky Mountains. We will need more responses from the Midwest and New England. We also realize from the low variation in region that splitting up our sample by state will give us a more granular analysis on the effect of location on vaccine sentiment. 
```{r echo=FALSE}

region_label <- c("New England",	"Middle Atlantic",	"South Atlantic", "East South Central",	"East North Central",	"West South Central",	"West North Central",	"Mountain",	"Pacific")
region <- c(1:9)
region_df <- data.frame(region,region_label)
regions <- data %>% select(region) %>% filter(!is.na(region)) %>%  group_by(region) %>% summarise(num_respondents = n()/20) %>% inner_join(region_df,by=c("region"))

regions

```

We also looked at the genders of our respondents. The sample is more balanced with respect to gender with other demographic attributes like we want, but the sample can use more male responses, as well as responses from those in the trans/non-binary community. 
```{r echo=FALSE}

genders <- data %>% select(gender) %>% filter(!is.na(gender)) %>%  group_by(gender) %>% summarise(num_respondents = n()/20)

genders

```
We also looked at the ages of our sample. We noticed that all our respondents are young adults, and we need more samples from the elderly and middle-aged adults to get a better prediction for age as their is more likely to be variation between generations as opposed to ages within a generation.
```{r echo=FALSE}

ages <- data %>% select(yearOfBirth) %>% filter(!is.na(yearOfBirth))  %>% mutate(age = 2021-as.numeric(yearOfBirth)) %>%  group_by(age) %>% summarise(num_respondents = n()/20)
ages[is.na(c("age"))] <- "Prefer not to say"
ages
```
### Modeling

Our utility model is as follows: 
$$
Uj = \beta_{1}x^{value} + \beta_{2}x^{penalty} + \beta_{3}x^{accessibility} + \beta_{4}x^{cash} \beta_{5}x^{groceries} \beta_{6}x^{internet} \beta_{7}x^{sport}
$$
The first three beta values represent continuous attributes, and for every change in value, accessibility, and penalty, the utility for policy j will increase by the beta value for that attribute * the level of the attribute. The last four beta values are for categorical attributes that can either be 0 or 1, with 0 denoting the attribute is not present and 1 denoting the presence of an attribute. If present, the utility for policy j will increase by the beta value for that attribute. 

Using the model and the choice data, we then ran the logitr model using preference space to estimate the beta coefficients. Running a summary of the results returned to us the estimated coefficients and the standard error. It also returned to us the log likelihood that the coefficients are correct and can be used to accurately estimate utility. 

```{r echo=FALSE}
library(janitor)
library(logitr)

# Clean up names of created variables
data <- clean_names(data)

# Estimate the model
model <- logitr(
    data   = data,
    outcome = "choice",
    obsID  = "obs_id",
    pars   = c(
        "value", 
        "penalty",
        "accessibility",
        "incentive_cash",
        "incentive_grocery_store",
        "incentive_internet",
        "incentive_sport_tickets"
    )
)

# View summary of results
summary(model)

```

We then validated the accuracy of the model by checking whether the model is at a maximum, because we need to maximize log likelihood. We checked the results against the first-order and second-order derivatives of the model.

```{r echo=FALSE}

# Check the 1st order condition: Is the gradient at the solution zero?
model$gradient

# 2nd order condition: Is the hessian negative definite?
# (If all the eigenvalues are negative, the hessian is negative definite)
eigen(model$hessian)$values

``` 
The first derivates for each attribute were close but not equal to 0. The second order derivatives in the hessian are all negative, denoting that the model has a maximum and is curved down. Since most first order derivatives are positive and all second order derivatives are negative, we can infer that the optimal values for betas are higher than estimated by the model, and for attributes with a negative first derivative, the actual values for betas are lower than estimated. But we concluded that with more data it would be easier to find measurable optimal values for beta. 

We then extracted the coefficients and standard errors to reference when plotting each attribute. 
```{r echo=FALSE}
coefs <- coef(model)
coefs

ses <- se(model)
ses
```

After getting the estimates and errors for beta, we proceeded to plot the utility for each attribute with each beta estimate. For plotting each attribute:

- We created a new data frame containing estimates plus upper and lower bound estimates calculated by the estimated coefficient, the standard error, and the attribute level. The upper and lower bounds are the 95% confidence interval for the estimate, or beta +- 2* std_err. 
- We plotted the attribute and the upper and lower bounds. For categorical attributes, we used box and whiskers plots to show the confidence interval. For continuous attributes, we shaded in the confidence interval. 

#### Plot for value of incentive
```{r echo=FALSE}
df_value <- data.frame(value =unique(data$value)) %>% 
    mutate(
        diff    = value - min(value),
        utility = diff*coefs['value'],
        upper =  diff*(coefs['value']+2*ses['value']),
        lower =  diff*(coefs['value']-2*ses['value'])
    )
    

# Get upper and lower bounds (plots should have the same y-axis)
ymin <- floor(min(df_value$lower))
ymax <- ceiling(max(df_value$upper))

# Plot the utility for each attribute
plot_value <- df_value %>% 
    ggplot(aes(x = value, y = utility,ymin=lower,ymax=upper)) +
    geom_line() +
    geom_ribbon(alpha=0.2) +
    scale_y_continuous(limits = c(ymin, ymax)) +
    labs(x = 'Value of incentive ($)', y = 'Utility') +
    theme_bw()

plot_value
```

#### Plot for accessibility to vaccination center
```{r echo=FALSE}

df_accessibility <- data.frame(accessibility = unique(data$accessibility)) %>% 
    mutate(
        diff    = accessibility - min(accessibility),
        utility = diff*coefs['accessibility'],
        upper =  diff*(coefs['accessibility']+2*ses['accessibility']),
        lower =  diff*(coefs['accessibility']-2*ses['accessibility'])
)

# Get upper and lower bounds (plots should have the same y-axis)
ymin <- floor(min(df_accessibility$lower))
ymax <- ceiling(max(df_accessibility$upper))

plot_accessibility <- df_accessibility %>% 
    ggplot(aes(x = accessibility, y = utility,ymin=lower,ymax=upper)) +
    geom_line() +
    geom_ribbon(alpha=0.2) +
    scale_y_continuous(limits = c(ymin, ymax)) +
    labs(x = 'Distance of nearest vaccination center (miles)', y = 'Utility') +
    theme_bw()

plot_accessibility

```

#### Plot for non-compliance penalty
```{r echo=FALSE}
df_penalty <- data.frame(penalty = unique(data$penalty)) %>% 
    mutate(
        diff    = penalty - min(penalty),
        utility = diff*coefs['penalty'],
        upper =  diff*(coefs['penalty']+2*ses['penalty']),
        lower =  diff*(coefs['penalty']-2*ses['penalty'])
    )
# Get upper and lower bounds (plots should have the same y-axis)
ymin <- floor(min(df_penalty$lower))
ymax <- ceiling(max(df_penalty$upper))

plot_penalty<- df_penalty %>% 
    ggplot(aes(x = penalty, y = utility, ymin=lower, ymax=upper)) +
    geom_line() +
    geom_ribbon(alpha=0.2) +
    scale_y_continuous(limits = c(ymin, ymax)) +
    labs(x = 'Penalty for non-compliance ($)', y = 'Utility') +
    theme_bw()

plot_penalty
```

#### Plot for cash incentives
```{r echo=FALSE}
df_cash <- data.frame(incentive_cash = unique(data$incentive_cash)) %>% 
    mutate(
        utility = incentive_cash*coefs['incentive_cash'],
        upper =  incentive_cash*(coefs['incentive_cash']+2*ses['incentive_cash']),
        lower =  incentive_cash*(coefs['incentive_cash']-2*ses['incentive_cash'])
    )

# Get upper and lower bounds (plots should have the same y-axis)
ymin <- floor(min(df_cash$lower))
ymax <- ceiling(max(df_cash$upper))

plot_cash<- df_cash %>% 
    ggplot(aes(x = incentive_cash, y = utility, ymin=lower, ymax=upper)) +
    geom_point() +
    geom_errorbar(width=0.3)  +
    scale_y_continuous(limits = c(ymin, ymax)) +
    labs(x = 'Cash incentive?', y = 'Utility') +
    theme_bw()

plot_cash
```

#### Plot for grocery store credit incentives
```{r echo=FALSE}
df_grocery_store <- data.frame(incentive_grocery_store = unique(data$incentive_grocery_store)) %>% 
    mutate(
        utility = incentive_grocery_store*coefs['incentive_grocery_store'],
        upper =  incentive_grocery_store*(coefs['incentive_grocery_store']+2*ses['incentive_grocery_store']),
        lower =  incentive_grocery_store*(coefs['incentive_grocery_store']-2*ses['incentive_grocery_store'])
    )

# Get upper and lower bounds (plots should have the same y-axis)
ymin <- floor(min(df_grocery_store$lower))
ymax <- ceiling(max(df_grocery_store$upper))

plot_grocery_store <- df_grocery_store %>% 
    ggplot(aes(x = incentive_grocery_store, y = utility, ymin=lower, ymax=upper)) +
    geom_point() +
    geom_errorbar(width=0.3) +
    scale_y_continuous(limits = c(ymin, ymax)) +
    labs(x = 'Grocery store incentive?', y = 'Utility') +
    theme_bw()

plot_grocery_store
```

#### Plot for internet bill credit incentives
```{r echo=FALSE}
df_internet <- data.frame(incentive_internet = unique(data$incentive_internet)) %>% 
    mutate(
        utility = incentive_internet*coefs['incentive_internet'],
        upper =  incentive_internet*(coefs['incentive_internet']+2*ses['incentive_internet']),
        lower =  incentive_internet*(coefs['incentive_internet']-2*ses['incentive_internet'])
    )

# Get upper and lower bounds (plots should have the same y-axis)
ymin <- floor(min(df_internet$lower))
ymax <- ceiling(max(df_internet$upper))

plot_internet <- df_internet %>% 
    ggplot(aes(x = incentive_internet , y = utility, ymin=lower, ymax=upper)) +
    geom_point() +
    geom_errorbar(width=0.3) +
    scale_y_continuous(limits = c(ymin, ymax)) +
    labs(x = 'Internet bill incentive?', y = 'Utility') +
    theme_bw()

plot_internet
```

#### Plot for sporting event tickets incentives
```{r echo=FALSE}
df_sport_tickets <- data.frame(incentive_sport_tickets  = unique(data$incentive_sport_tickets)) %>% 
    mutate(
        utility = incentive_sport_tickets *coefs['incentive_sport_tickets'],
        upper =  incentive_sport_tickets*(coefs['incentive_sport_tickets']+2*ses['incentive_sport_tickets']),
        lower =  incentive_sport_tickets*(coefs['incentive_sport_tickets']-2*ses['incentive_sport_tickets'])
    )

# Get upper and lower bounds (plots should have the same y-axis)
ymin <- floor(min(df_sport_tickets$lower))
ymax <- ceiling(max(df_sport_tickets$upper))

plot_sport_tickets  <- df_sport_tickets  %>% 
    ggplot(aes(x = incentive_sport_tickets , y = utility, ymin=lower, ymax=upper)) +
    geom_point() +
    geom_errorbar(width=0.3) +
    scale_y_continuous(limits = c(ymin, ymax)) +
    labs(x = 'Sporting event tickets incentive?', y = 'Utility') +
    theme_bw()

plot_sport_tickets 
```

# Changes to Final Survey

- We removed unnecessary images that may confuse respondents. 
- We wanted to find out how many people have experienced mistreatment in getting healthcare and see mandates for them, so we added a question asking this. 
- We changed the format of every question to a Yes/No multiple choice button to make the design look more appealing. 
- 

# Appendix



